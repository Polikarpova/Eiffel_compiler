# Eiffel_compiler
# Eiffel_compiler
University assignment

Возьмём за правило затягивать изменения с опцией --rebase:
git pull --rebase

Syntax in Eiffel:
- таблички [старый синтаксис]: http://rigaux.org/language-study/syntax-across-languages-per-language/Eiffel.html
- Описание различных statement с различными вариантами их использования [старый синтаксис?]: https://www.infor.uva.es/~felix/priii/sintaxis.html
- https://www.eiffel.org/doc/eiffel/Quick_reference_to_the_Eiffel_programming_language
- Полезная статейка о классах: https://www.eiffel.org/doc/solutions/Eiffel_Classes

Примеры кода uzh-software-construction
This repository holds various snippets of Eiffel in order to illustrate particular concepts I explained in the UZH course Software Construction.
https://github.com/rmatil/uzh-software-construction

---

## План семантического анализа ##

Семантический анализ начинается после синтаксического анализа и предполагает отсутствие грубых синтаксических ошибок наподобие незакрытых скобок/блоков `do .. end`.

***Внимание***: все осуществляемые проверки должны быть согласованы с референсным компилятором (Eiffel Studio 18.07).

ПРОХОД 1: Поиск всех пользовательских типов (классов)

Цель: найти и запомнить все объявления классов (их имена).

Проверки: 
 - Имена классов, конфликтующие друг с другом и с зарезервированными именами RTL (`INTEGER`, `ARRAY`, ...).


ПРОХОД 2: Поиск всех членов (features) для всех пользовательских классов

Цель: найти все объявления членов классов (их имена и прототипы), а также запомнить указания на области видимости.

Проверки: 
 - Имена членов классов, конфликтующие друг с другом, с __именами классов__ и с зарезервированными именами RTL (`INTEGER`, `ARRAY`, ...).
 - Существование типов, используемых в указаниях областей видимости и объявлениях членов классов (типы полей, возвращаемые значения и параметры методов). В т.ч. проверка существования типов-массивов (существование типа элемента).


ПРОХОД 3: Определение всех методов пользовательских классов

Цель: разобрать тела методов, преобразовать необходимые конструкции и подготовить методы (и классы) к генерации байт-кода.


ПРОХОД 3.1: [Выполняется для каждого метода] Поиск локальных переменных

Цель: найти все объявления членов классов (их имена и прототипы), а также запомнить указания на области видимости.

Проверки: 
 - Имена локальных переменных, конфликтующие друг с другом и с зарезервированными именами RTL (`INTEGER`, `ARRAY`, ...). **Выяснить поведение и проверять конфликты по именам с членами этого же класса.**
 - Существование типов, используемых в объявлениях локальных переменных. В т.ч. проверка существования типов-массивов (существование типа элемента).

 
ПРОХОД 3.2: [Выполняется для каждого *statement* в теле метода (блока)] Атрибутирование типами и проверка совместимости узлов синтаксического дерева 

Цель: проставить все типы ко всем узлам дерева, дочерним к *statement*, выполнить обратное контекстное уточнение и необходимые преобразования дерева (приведение типов, инвертирование условия цикла и т.п.).

Проверки: 
	(--- выписать ---)

Примечание. Для реализации видится полезным:
 - Наличие у синтаксических конструкций информации об ожидаемых типах дочерних выражений (термин: *expected*, *required*). Например, `A := B;` подразумевает `A` - левостороннее (*lvalue*) выражение.
 - Наличие у типов информации о типах, выводимых из данного. Например, `ID` приводится к *lvalue* (хотя `ID` - ещё пока не тип), `INTEGER` - к `FLOAT`.
